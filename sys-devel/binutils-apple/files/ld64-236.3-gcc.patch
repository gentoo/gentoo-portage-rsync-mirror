Provide c++11 headers from tr1 include directory and namespace.

Work around weird namespacing bug in gcc-4.2.1 where class ld::Section
conflicts with template mach_o::relocatable::Section by renaming the latter to
MRFSection (could possibly be done using sed from ebuild or avoided by figuring
out, what's actually going on with those namespaces).

diff -ur ld64-236.3.orig/src/ld/InputFiles.h ld64-236.3/src/ld/InputFiles.h
--- ld64-236.3.orig/src/ld/InputFiles.h	2014-04-05 00:42:29.000000000 +0200
+++ ld64-236.3/src/ld/InputFiles.h	2015-01-11 22:43:08.000000000 +0100
@@ -46,6 +46,14 @@
 #include <pthread.h>
 #endif
 
+#ifdef __GLIBCXX__
+#include <tr1/unordered_map>
+#define UNORDERED_MAP tr1::unordered_map
+#else
+#include <unordered_map>
+#define UNORDERED_MAP unordered_map
+#endif
+
 #include <vector>
 
 #include "Options.h"
@@ -107,7 +115,7 @@
 	static void					parseWorkerThread(InputFiles *inputFiles);
 	void						startThread(void (*threadFunc)(InputFiles *)) const;
 
-	typedef std::unordered_map<const char*, ld::dylib::File*, CStringHash, CStringEquals>	InstallNameToDylib;
+	typedef std::UNORDERED_MAP<const char*, ld::dylib::File*, CStringHash, CStringEquals>	InstallNameToDylib;
 
 	const Options&				_options;
 	std::vector<ld::File*>		_inputFiles;
diff -ur ld64-236.3.orig/src/ld/LinkEditClassic.hpp ld64-236.3/src/ld/LinkEditClassic.hpp
--- ld64-236.3.orig/src/ld/LinkEditClassic.hpp	2014-04-05 00:42:29.000000000 +0200
+++ ld64-236.3/src/ld/LinkEditClassic.hpp	2015-01-11 22:44:04.000000000 +0100
@@ -31,8 +31,13 @@
 #include <limits.h>
 #include <unistd.h>
 
-#include <vector>
+#ifdef __GLIBCXX__
+#include <tr1/unordered_map>
+#define UNORDERED_MAP tr1::unordered_map
+#else
 #include <unordered_map>
+#define UNORDERED_MAP unordered_map
+#endif
 
 #include "Options.h"
 #include "ld.hpp"
@@ -92,7 +97,7 @@
 
 private:
 	enum { kBufferSize = 0x01000000 };
-	typedef std::unordered_map<const char*, int32_t, CStringHash, CStringEquals> StringToOffset;
+	typedef std::UNORDERED_MAP<const char*, int32_t, CStringHash, CStringEquals> StringToOffset;
 
 	const uint32_t							_pointerSize;
 	std::vector<char*>						_fullBuffers;
diff -ur ld64-236.3.orig/src/ld/Options.cpp ld64-236.3/src/ld/Options.cpp
--- ld64-236.3.orig/src/ld/Options.cpp	2015-01-11 17:35:08.000000000 +0100
+++ ld64-236.3/src/ld/Options.cpp	2015-01-11 22:47:34.000000000 +0100
@@ -4335,7 +4335,7 @@
 
 	// make sure all required exported symbols exist
 	std::vector<const char*> impliedExports;
-	for (NameSet::iterator it=fExportSymbols.regularBegin(); it != fExportSymbols.regularEnd(); ++it) {
+	for (NameSet::const_iterator it=fExportSymbols.regularBegin(); it != fExportSymbols.regularEnd(); ++it) {
 		const char* name = *it;
 		const int len = strlen(name);
 		if ( (strcmp(&name[len-3], ".eh") == 0) || (strncmp(name, ".objc_category_name_", 20) == 0) ) {
@@ -4367,7 +4367,7 @@
 	}
 
 	// make sure all required re-exported symbols exist
-	for (NameSet::iterator it=fReExportSymbols.regularBegin(); it != fReExportSymbols.regularEnd(); ++it) {
+	for (NameSet::const_iterator it=fReExportSymbols.regularBegin(); it != fReExportSymbols.regularEnd(); ++it) {
 		fInitialUndefines.push_back(*it);
 	}
 	
diff -ur ld64-236.3.orig/src/ld/Options.h ld64-236.3/src/ld/Options.h
--- ld64-236.3.orig/src/ld/Options.h	2014-04-05 00:42:29.000000000 +0200
+++ ld64-236.3/src/ld/Options.h	2015-01-11 22:44:00.000000000 +0100
@@ -30,8 +30,17 @@
 #include <mach/machine.h>
 
 #include <vector>
+#ifdef __GLIBCXX__
+#include <tr1/unordered_set>
+#include <tr1/unordered_map>
+#define UNORDERED_MAP tr1::unordered_map
+#define UNORDERED_SET tr1::unordered_set
+#else
 #include <unordered_set>
 #include <unordered_map>
+#define UNORDERED_MAP unordered_map
+#define UNORDERED_SET unordered_set
+#endif
 
 #include "ld.hpp"
 #include "Snapshot.h"
@@ -376,8 +385,8 @@
 	const std::vector<SectionRename>& sectionRenames() const { return fSectionRenames; }
 
 private:
-	typedef std::unordered_map<const char*, unsigned int, ld::CStringHash, ld::CStringEquals> NameToOrder;
-	typedef std::unordered_set<const char*, ld::CStringHash, ld::CStringEquals>  NameSet;
+	typedef std::UNORDERED_MAP<const char*, unsigned int, ld::CStringHash, ld::CStringEquals> NameToOrder;
+	typedef std::UNORDERED_SET<const char*, ld::CStringHash, ld::CStringEquals>  NameSet;
 	enum ExportMode { kExportDefault, kExportSome, kDontExportSome };
 	enum LibrarySearchMode { kSearchDylibAndArchiveInEachDir, kSearchAllDirsForDylibsThenAllDirsForArchives };
 	enum InterposeMode { kInterposeNone, kInterposeAllExternal, kInterposeSome };
@@ -389,8 +398,8 @@
 		bool					containsNonWildcard(const char*) const;
 		bool					empty() const			{ return fRegular.empty() && fWildCard.empty(); }
 		bool					hasWildCards() const	{ return !fWildCard.empty(); }
-		NameSet::iterator		regularBegin() const	{ return fRegular.begin(); }
-		NameSet::iterator		regularEnd() const		{ return fRegular.end(); }
+		NameSet::const_iterator		regularBegin() const	{ return fRegular.begin(); }
+		NameSet::const_iterator		regularEnd() const		{ return fRegular.end(); }
 		void					remove(const NameSet&); 
 	private:
 		static bool				hasWildCards(const char*);
diff -ur ld64-236.3.orig/src/ld/OutputFile.cpp ld64-236.3/src/ld/OutputFile.cpp
--- ld64-236.3.orig/src/ld/OutputFile.cpp	2015-01-11 17:35:08.000000000 +0100
+++ ld64-236.3/src/ld/OutputFile.cpp	2015-01-12 00:24:43.000000000 +0100
@@ -50,7 +50,13 @@
 #include <vector>
 #include <list>
 #include <algorithm>
+#ifdef __GLIBCXX__
+#include <tr1/unordered_set>
+#define UNORDERED_SET tr1::unordered_set
+#else
 #include <unordered_set>
+#define UNORDERED_SET unordered_set
+#endif
 
 #include <CommonCrypto/CommonDigest.h>
 #include <AvailabilityMacros.h>
@@ -4699,7 +4705,7 @@
 	const char* filename = NULL;
 	bool wroteStartSO = false;
 	state.stabs.reserve(atomsNeedingDebugNotes.size()*4);
-	std::unordered_set<const char*, CStringHash, CStringEquals>  seenFiles;
+	std::UNORDERED_SET<const char*, CStringHash, CStringEquals>  seenFiles;
 	for (std::vector<const ld::Atom*>::iterator it=atomsNeedingDebugNotes.begin(); it != atomsNeedingDebugNotes.end(); it++) {
 		const ld::Atom* atom = *it;
 		const ld::File* atomFile = atom->file();
diff -ur ld64-236.3.orig/src/ld/Resolver.h ld64-236.3/src/ld/Resolver.h
--- ld64-236.3.orig/src/ld/Resolver.h	2014-04-05 00:42:29.000000000 +0200
+++ ld64-236.3/src/ld/Resolver.h	2015-01-11 22:49:14.000000000 +0100
@@ -42,7 +42,13 @@
 #include <mach-o/dyld.h>
 
 #include <vector>
+#ifdef __GLIBCXX__
+#include <tr1/unordered_set>
+#define UNORDERED_SET tr1::unordered_set
+#else
 #include <unordered_set>
+#define UNORDERED_SET unordered_set
+#endif
 
 #include "Options.h"
 #include "ld.hpp"
@@ -103,7 +109,7 @@
 	void					doLinkerOption(const std::vector<const char*>& linkerOption, const char* fileName);
 	void					dumpAtoms();
 
-	typedef std::unordered_set<const char*, CStringHash, CStringEquals>  StringSet;
+	typedef std::UNORDERED_SET<const char*, CStringHash, CStringEquals>  StringSet;
 
 	class NotLive {
 	public:
diff -ur ld64-236.3.orig/src/ld/SymbolTable.h ld64-236.3/src/ld/SymbolTable.h
--- ld64-236.3.orig/src/ld/SymbolTable.h	2014-04-05 00:42:29.000000000 +0200
+++ ld64-236.3/src/ld/SymbolTable.h	2015-01-11 22:46:19.000000000 +0100
@@ -42,7 +42,13 @@
 #include <mach-o/dyld.h>
 
 #include <vector>
+#ifdef __GLIBCXX__
+#include <tr1/unordered_map>
+#define UNORDERED_MAP tr1::unordered_map
+#else
 #include <unordered_map>
+#define UNORDERED_MAP unordered_map
+#endif
 
 #include "Options.h"
 #include "ld.hpp"
@@ -57,38 +63,38 @@
 	typedef uint32_t IndirectBindingSlot;
 
 private:
-	typedef std::unordered_map<const char*, IndirectBindingSlot, CStringHash, CStringEquals> NameToSlot;
+	typedef std::UNORDERED_MAP<const char*, IndirectBindingSlot, CStringHash, CStringEquals> NameToSlot;
 
 	class ContentFuncs {
 	public:
 		size_t	operator()(const ld::Atom*) const;
 		bool	operator()(const ld::Atom* left, const ld::Atom* right) const;
 	};
-	typedef std::unordered_map<const ld::Atom*, IndirectBindingSlot, ContentFuncs, ContentFuncs> ContentToSlot;
+	typedef std::UNORDERED_MAP<const ld::Atom*, IndirectBindingSlot, ContentFuncs, ContentFuncs> ContentToSlot;
 
 	class ReferencesHashFuncs {
 	public:
 		size_t	operator()(const ld::Atom*) const;
 		bool	operator()(const ld::Atom* left, const ld::Atom* right) const;
 	};
-	typedef std::unordered_map<const ld::Atom*, IndirectBindingSlot, ReferencesHashFuncs, ReferencesHashFuncs> ReferencesToSlot;
+	typedef std::UNORDERED_MAP<const ld::Atom*, IndirectBindingSlot, ReferencesHashFuncs, ReferencesHashFuncs> ReferencesToSlot;
 
 	class CStringHashFuncs {
 	public:
 		size_t	operator()(const ld::Atom*) const;
 		bool	operator()(const ld::Atom* left, const ld::Atom* right) const;
 	};
-	typedef std::unordered_map<const ld::Atom*, IndirectBindingSlot, CStringHashFuncs, CStringHashFuncs> CStringToSlot;
+	typedef std::UNORDERED_MAP<const ld::Atom*, IndirectBindingSlot, CStringHashFuncs, CStringHashFuncs> CStringToSlot;
 
 	class UTF16StringHashFuncs {
 	public:
 		size_t	operator()(const ld::Atom*) const;
 		bool	operator()(const ld::Atom* left, const ld::Atom* right) const;
 	};
-	typedef std::unordered_map<const ld::Atom*, IndirectBindingSlot, UTF16StringHashFuncs, UTF16StringHashFuncs> UTF16StringToSlot;
+	typedef std::UNORDERED_MAP<const ld::Atom*, IndirectBindingSlot, UTF16StringHashFuncs, UTF16StringHashFuncs> UTF16StringToSlot;
 
 	typedef std::map<IndirectBindingSlot, const char*> SlotToName;
-	typedef std::unordered_map<const char*, CStringToSlot*, CStringHash, CStringEquals> NameToMap;
+	typedef std::UNORDERED_MAP<const char*, CStringToSlot*, CStringHash, CStringEquals> NameToMap;
     
     typedef std::vector<const ld::Atom *> DuplicatedSymbolAtomList;
     typedef std::map<const char *, DuplicatedSymbolAtomList * > DuplicateSymbols;
diff -ur ld64-236.3.orig/src/ld/ld.cpp ld64-236.3/src/ld/ld.cpp
--- ld64-236.3.orig/src/ld/ld.cpp	2015-01-11 17:35:08.000000000 +0100
+++ ld64-236.3/src/ld/ld.cpp	2015-01-11 22:42:58.000000000 +0100
@@ -54,7 +54,13 @@
 #include <vector>
 #include <list>
 #include <algorithm>
+#ifdef __GLIBCXX__
+#include <tr1/unordered_map>
+#define UNORDERED_MAP tr1::unordered_map
+#else
 #include <unordered_map>
+#define UNORDERED_MAP unordered_map
+#endif
 #include <cxxabi.h>
 
 #include "Options.h"
@@ -150,7 +156,7 @@
 	struct SectionEquals {
 		bool operator()(const ld::Section* left, const ld::Section* right) const;
 	};
-	typedef std::unordered_map<const ld::Section*, FinalSection*, SectionHash, SectionEquals> SectionInToOut;
+	typedef std::UNORDERED_MAP<const ld::Section*, FinalSection*, SectionHash, SectionEquals> SectionInToOut;
 	
 
 	SectionInToOut			_sectionInToFinalMap;
diff -ur ld64-236.3.orig/src/ld/ld.hpp ld64-236.3/src/ld/ld.hpp
--- ld64-236.3.orig/src/ld/ld.hpp	2014-04-05 00:42:29.000000000 +0200
+++ ld64-236.3/src/ld/ld.hpp	2015-01-11 22:42:46.000000000 +0100
@@ -32,7 +32,13 @@
 #include <assert.h>
 
 #include <vector>
+#ifdef __GLIBCXX__
+#include <tr1/unordered_set>
+#define UNORDERED_SET tr1::unordered_set
+#else
 #include <unordered_set>
+#define UNORDERED_SET unordered_set
+#endif
 
 #include "configure.h"
 
@@ -821,7 +827,7 @@
 	bool operator()(const char* left, const char* right) const { return (strcmp(left, right) == 0); }
 };
 
-typedef	std::unordered_set<const char*, ld::CStringHash, ld::CStringEquals>  CStringSet;
+typedef	std::UNORDERED_SET<const char*, ld::CStringHash, ld::CStringEquals>  CStringSet;
 
 class Internal
 {
diff -ur ld64-236.3.orig/src/ld/parsers/archive_file.cpp ld64-236.3/src/ld/parsers/archive_file.cpp
--- ld64-236.3.orig/src/ld/parsers/archive_file.cpp	2015-01-11 17:35:08.000000000 +0100
+++ ld64-236.3/src/ld/parsers/archive_file.cpp	2015-01-11 22:41:37.000000000 +0100
@@ -33,7 +33,13 @@
 #include <set>
 #include <map>
 #include <algorithm>
+#ifdef __GLIBCXX__
+#include <tr1/unordered_map>
+#define UNORDERED_MAP tr1::unordered_map
+#else
 #include <unordered_map>
+#define UNORDERED_MAP unordered_map
+#endif
 
 #include "MachOFileAbstraction.hpp"
 #include "Architectures.hpp"
@@ -116,7 +122,7 @@
 	struct MemberState { ld::relocatable::File* file; const Entry *entry; bool logged; bool loaded; uint32_t index;};
 	bool											loadMember(MemberState& state, ld::File::AtomHandler& handler, const char *format, ...) const;
 
-	typedef std::unordered_map<const char*, const struct ranlib*, ld::CStringHash, ld::CStringEquals> NameToEntryMap;
+	typedef std::UNORDERED_MAP<const char*, const struct ranlib*, ld::CStringHash, ld::CStringEquals> NameToEntryMap;
 
 	typedef typename A::P							P;
 	typedef typename A::P::E						E;
diff -ur ld64-236.3.orig/src/ld/parsers/lto_file.cpp ld64-236.3/src/ld/parsers/lto_file.cpp
--- ld64-236.3.orig/src/ld/parsers/lto_file.cpp	2014-04-05 00:42:29.000000000 +0200
+++ ld64-236.3/src/ld/parsers/lto_file.cpp	2015-01-11 22:44:48.000000000 +0100
@@ -33,8 +33,17 @@
 #include <pthread.h>
 #include <mach-o/dyld.h>
 #include <vector>
+#ifdef __GLIBCXX__
+#include <tr1/unordered_set>
+#include <tr1/unordered_map>
+#define UNORDERED_MAP tr1::unordered_map
+#define UNORDERED_SET tr1::unordered_set
+#else
 #include <unordered_set>
 #include <unordered_map>
+#define UNORDERED_MAP unordered_map
+#define UNORDERED_SET unordered_set
+#endif
 
 #include "MachOFileAbstraction.hpp"
 #include "Architectures.hpp"
@@ -217,8 +226,8 @@
 	static void ltoDiagnosticHandler(lto_codegen_diagnostic_severity_t, const char*, void*);
 #endif
 
-	typedef	std::unordered_set<const char*, ld::CStringHash, ld::CStringEquals>  CStringSet;
-	typedef std::unordered_map<const char*, Atom*, ld::CStringHash, ld::CStringEquals> CStringToAtom;
+	typedef	std::UNORDERED_SET<const char*, ld::CStringHash, ld::CStringEquals>  CStringSet;
+	typedef std::UNORDERED_MAP<const char*, Atom*, ld::CStringHash, ld::CStringEquals> CStringToAtom;
 	
 	class AtomSyncer : public ld::File::AtomHandler {
 	public:
diff -ur ld64-236.3.orig/src/ld/parsers/macho_dylib_file.cpp ld64-236.3/src/ld/parsers/macho_dylib_file.cpp
--- ld64-236.3.orig/src/ld/parsers/macho_dylib_file.cpp	2015-01-11 17:35:08.000000000 +0100
+++ ld64-236.3/src/ld/parsers/macho_dylib_file.cpp	2015-01-11 22:45:17.000000000 +0100
@@ -34,8 +34,17 @@
 #include <vector>
 #include <set>
 #include <algorithm>
-#include <unordered_map>
+#ifdef __GLIBCXX__
+#include <tr1/unordered_set>
+#include <tr1/unordered_map>
+#define UNORDERED_MAP tr1::unordered_map
+#define UNORDERED_SET tr1::unordered_set
+#else
 #include <unordered_set>
+#include <unordered_map>
+#define UNORDERED_MAP unordered_map
+#define UNORDERED_SET unordered_set
+#endif
 
 #include "Architectures.hpp"
 #include "MachOFileAbstraction.hpp"
@@ -189,8 +198,8 @@
 		};
 	};
 	struct AtomAndWeak { ld::Atom* atom; bool weakDef; bool tlv; pint_t address; };
-	typedef std::unordered_map<const char*, AtomAndWeak, ld::CStringHash, ld::CStringEquals> NameToAtomMap;
-	typedef std::unordered_set<const char*, CStringHash, ld::CStringEquals>  NameSet;
+	typedef std::UNORDERED_MAP<const char*, AtomAndWeak, ld::CStringHash, ld::CStringEquals> NameToAtomMap;
+	typedef std::UNORDERED_SET<const char*, CStringHash, ld::CStringEquals>  NameSet;
 
 	struct Dependent { const char* path; File<A>* dylib; bool reExport; };
 
@@ -548,14 +557,18 @@
 		if ( _s_logHashtable ) fprintf(stderr, "ld: building hashtable of %u toc entries for %s\n", dynamicInfo->nextdefsym(), this->path());
 		const macho_nlist<P>* start = &symbolTable[dynamicInfo->iextdefsym()];
 		const macho_nlist<P>* end = &start[dynamicInfo->nextdefsym()];
+#ifndef __GLIBCXX__
 		_atoms.reserve(dynamicInfo->nextdefsym()); // set initial bucket count
+#endif
 		for (const macho_nlist<P>* sym=start; sym < end; ++sym) {
 			this->addSymbol(&strings[sym->n_strx()], (sym->n_desc() & N_WEAK_DEF) != 0, false, sym->n_value());
 		}
 	}
 	else {
 		int32_t count = dynamicInfo->ntoc();
+#ifndef __GLIBCXX__
 		_atoms.reserve(count); // set initial bucket count
+#endif
 		if ( _s_logHashtable ) fprintf(stderr, "ld: building hashtable of %u entries for %s\n", count, this->path());
 		const struct dylib_table_of_contents* toc = (dylib_table_of_contents*)(fileContent + dynamicInfo->tocoff());
 		for (int32_t i = 0; i < count; ++i) {
diff -ur ld64-236.3.orig/src/ld/parsers/macho_relocatable_file.cpp ld64-236.3/src/ld/parsers/macho_relocatable_file.cpp
--- ld64-236.3.orig/src/ld/parsers/macho_relocatable_file.cpp	2014-04-05 00:42:29.000000000 +0200
+++ ld64-236.3/src/ld/parsers/macho_relocatable_file.cpp	2015-01-11 23:08:13.000000000 +0100
@@ -62,7 +62,7 @@
 // forward reference
 template <typename A> class Parser;
 template <typename A> class Atom;
-template <typename A> class Section;
+template <typename A> class MRFSection;
 template <typename A> class CFISection;
 template <typename A> class CUSection;
 
@@ -100,14 +100,14 @@
 	const uint8_t*										fileContent()					{ return _fileContent; }
 private:
 	friend class Atom<A>;
-	friend class Section<A>;
+	friend class MRFSection<A>;
 	friend class Parser<A>;
 	friend class CFISection<A>::OAS;
 	
 	typedef typename A::P					P;
 	
 	const uint8_t*							_fileContent;
-	Section<A>**							_sectionsArray;
+	MRFSection<A>**							_sectionsArray;
 	uint8_t*								_atomsArray;
 	uint32_t								_sectionsArrayCount;
 	uint32_t								_atomsArrayCount;
@@ -129,14 +129,14 @@
 
 
 template <typename A>
-class Section : public ld::Section
+class MRFSection : public ld::Section
 {
 public:
 	typedef typename A::P::uint_t	pint_t;
 	typedef typename A::P			P;
 	typedef typename A::P::E		E;
 
-	virtual							~Section()					{ }
+	virtual							~MRFSection()					{ }
 	class File<A>&					file() const				{ return _file; }
 	const macho_section<P>*			machoSection() const		{ return _machOSection; }
 	uint32_t						sectionNum(class Parser<A>&) const;
@@ -160,10 +160,10 @@
 	static const char*				makeSectionName(const macho_section<typename A::P>* s);
 
 protected:	
-						Section(File<A>& f, const macho_section<typename A::P>* s)
+						MRFSection(File<A>& f, const macho_section<typename A::P>* s)
 							: ld::Section(makeSegmentName(s), makeSectionName(s), sectionType(s)),
 								_file(f), _machOSection(s), _beginAtoms(NULL), _endAtoms(NULL), _hasAliases(false) { }
-						Section(File<A>& f, const char* segName, const char* sectName, ld::Section::Type t, bool hidden=false)
+						MRFSection(File<A>& f, const char* segName, const char* sectName, ld::Section::Type t, bool hidden=false)
 							: ld::Section(segName, sectName, t, hidden), _file(f), _machOSection(NULL), 
 								_beginAtoms(NULL), _endAtoms(NULL), _hasAliases(false) { }
 
@@ -186,11 +186,11 @@
 
 
 template <typename A>
-class CFISection : public Section<A>
+class CFISection : public MRFSection<A>
 {
 public:
 						CFISection(Parser<A>& parser, File<A>& f, const macho_section<typename A::P>* s)
-							: Section<A>(f, s) { }
+							: MRFSection<A>(f, s) { }
 	uint32_t			cfiCount();
 
 	virtual ld::Atom::ContentType	contentType()		{ return ld::Atom::typeCFI; }
@@ -250,11 +250,11 @@
 
 
 template <typename A>
-class CUSection : public Section<A>
+class CUSection : public MRFSection<A>
 {
 public:
 						CUSection(Parser<A>& parser, File<A>& f, const macho_section<typename A::P>* s)
-							: Section<A>(f, s) { }
+							: MRFSection<A>(f, s) { }
 
 	typedef typename A::P::uint_t	pint_t;
 	typedef typename A::P			P;
@@ -291,11 +291,11 @@
 
 
 template <typename A>
-class TentativeDefinitionSection : public Section<A>
+class TentativeDefinitionSection : public MRFSection<A>
 {
 public:
 						TentativeDefinitionSection(Parser<A>& parser, File<A>& f)
-							: Section<A>(f, "__DATA", "__comm/tent", ld::Section::typeTentativeDefs)  {}
+							: MRFSection<A>(f, "__DATA", "__comm/tent", ld::Section::typeTentativeDefs)  {}
 
 	virtual ld::Atom::ContentType	contentType()		{ return ld::Atom::typeZeroFill; }
 	virtual bool		addFollowOnFixups() const	{ return false; }
@@ -313,11 +313,11 @@
 
 
 template <typename A>
-class AbsoluteSymbolSection : public Section<A>
+class AbsoluteSymbolSection : public MRFSection<A>
 {
 public:
 						AbsoluteSymbolSection(Parser<A>& parser, File<A>& f)
-							: Section<A>(f, "__DATA", "__abs", ld::Section::typeAbsoluteSymbols, true)  {}
+							: MRFSection<A>(f, "__DATA", "__abs", ld::Section::typeAbsoluteSymbols, true)  {}
 
 	virtual ld::Atom::ContentType	contentType()		{ return ld::Atom::typeUnclassified; }
 	virtual bool					dontDeadStrip()		{ return false; }
@@ -339,7 +339,7 @@
 
 
 template <typename A>
-class SymboledSection : public Section<A>
+class SymboledSection : public MRFSection<A>
 {
 public:
 						SymboledSection(Parser<A>& parser, File<A>& f, const macho_section<typename A::P>* s);
@@ -371,11 +371,11 @@
 
 
 template <typename A>
-class ImplicitSizeSection : public Section<A>
+class ImplicitSizeSection : public MRFSection<A>
 {
 public:
 						ImplicitSizeSection(Parser<A>& parser, File<A>& f, const macho_section<typename A::P>* s)
-							: Section<A>(f, s) { }
+							: MRFSection<A>(f, s) { }
 	virtual uint32_t	computeAtomCount(class Parser<A>& parser, struct Parser<A>::LabelAndCFIBreakIterator& it, const struct Parser<A>::CFI_CU_InfoArrays&);
 	virtual uint32_t	appendAtoms(class Parser<A>& parser, uint8_t* buffer, struct Parser<A>::LabelAndCFIBreakIterator& it, const struct Parser<A>::CFI_CU_InfoArrays&);
 protected:
@@ -709,8 +709,8 @@
 
 public:
 	// methods for all atoms from mach-o object file
-			Section<A>&							sect() const			{ return (Section<A>&)section(); }
-			File<A>&							machofile() const			{ return ((Section<A>*)(this->_section))->file(); }
+			MRFSection<A>&							sect() const			{ return (MRFSection<A>&)section(); }
+			File<A>&							machofile() const			{ return ((MRFSection<A>*)(this->_section))->file(); }
 			void								setFixupsRange(uint32_t s, uint32_t c);
 			void								setUnwindInfoRange(uint32_t s, uint32_t c);
 			void								extendUnwindInfoRange();
@@ -727,7 +727,7 @@
 	typedef typename A::P::E					E;
 	typedef typename A::P::uint_t				pint_t;
 												// constuct via all attributes
-												Atom(Section<A>& sct, const char* nm, pint_t addr, uint64_t sz, 
+												Atom(MRFSection<A>& sct, const char* nm, pint_t addr, uint64_t sz, 
 													ld::Atom::Definition d, ld::Atom::Combine c, ld::Atom::Scope s, 
 													ld::Atom::ContentType ct, ld::Atom::SymbolTableInclusion i, 
 													bool dds, bool thumb, bool al, ld::Atom::Alignment a) 
@@ -737,7 +737,7 @@
 															_unwindInfoStartIndex(0), _fixupsCount(0),  
 															_lineInfoCount(0), _unwindInfoCount(0) { }
 												// construct via symbol table entry
-												Atom(Section<A>& sct, Parser<A>& parser, const macho_nlist<P>& sym, 
+												Atom(MRFSection<A>& sct, Parser<A>& parser, const macho_nlist<P>& sym, 
 																uint64_t sz, bool alias=false)
 														: ld::Atom((ld::Section&)sct, parser.definitionFromSymbol(sym), 
 																parser.combineFromSymbol(sym), parser.scopeFromSymbol(sym),
@@ -760,7 +760,7 @@
 
 private:
 	friend class Parser<A>;
-	friend class Section<A>;
+	friend class MRFSection<A>;
 	friend class CStringSection<A>;
 	friend class AbsoluteSymbolSection<A>;
 	
@@ -991,8 +991,8 @@
 	uint32_t										undefinedStartIndex() { return _undefinedStartIndex; }
 	uint32_t										undefinedEndIndex() { return _undefinedEndIndex; }
 	void											addFixup(FixupInAtom f) { _allFixups.push_back(f); }
-	Section<A>*										sectionForNum(unsigned int sectNum);
-	Section<A>*										sectionForAddress(pint_t addr);
+	MRFSection<A>*										sectionForNum(unsigned int sectNum);
+	MRFSection<A>*										sectionForAddress(pint_t addr);
 	Atom<A>*										findAtomByAddress(pint_t addr);
 	Atom<A>*										findAtomByAddressOrNullIfStub(pint_t addr);
 	Atom<A>*										findAtomByAddressOrLocalTargetOfStub(pint_t addr, uint32_t* offsetInAtom);
@@ -1034,7 +1034,7 @@
 									: sortedSymbolIndexes(ssa), sortedSymbolCount(ssc), cfiStartsArray(cfisa), 
 										cfiStartsCount(cfisc), fileHasOverlappingSymbols(ols),
 										newSection(false), cfiIndex(0), symIndex(0) {}
-		bool					next(Parser<A>& parser, const Section<A>& sect, uint32_t sectNum, pint_t startAddr, pint_t endAddr, 
+		bool					next(Parser<A>& parser, const MRFSection<A>& sect, uint32_t sectNum, pint_t startAddr, pint_t endAddr, 
 										pint_t* addr, pint_t* size, const macho_nlist<P>** sym);
 		pint_t					peek(Parser<A>& parser, pint_t startAddr, pint_t endAddr);
 		void					beginSection() { newSection = true; symIndex = 0; }
@@ -1063,7 +1063,7 @@
 
 
 private:
-	friend class Section<A>;
+	friend class MRFSection<A>;
 	
 	enum SectionType { sectionTypeIgnore, sectionTypeLiteral4, sectionTypeLiteral8, sectionTypeLiteral16, 
 						sectionTypeNonLazy, sectionTypeCFI, sectionTypeCString, sectionTypeCStringPointer, 
@@ -1404,7 +1404,7 @@
 // was becuase of a label, the symbol). Returns false when no more chunks.
 //
 template <typename A>
-bool Parser<A>::LabelAndCFIBreakIterator::next(Parser<A>& parser, const Section<A>& sect, uint32_t sectNum, pint_t startAddr, pint_t endAddr, 
+bool Parser<A>::LabelAndCFIBreakIterator::next(Parser<A>& parser, const MRFSection<A>& sect, uint32_t sectNum, pint_t startAddr, pint_t endAddr, 
 												pint_t* addr, pint_t* size, const macho_nlist<P>** symbol)
 {
 	// may not be a label on start of section, but need atom demarcation there
@@ -1590,7 +1590,7 @@
 	uint32_t sortedSymbolIndexes[_symbolsInSections];
 	this->makeSortedSymbolsArray(sortedSymbolIndexes, sortedSectionIndexes);
 		
-	// allocate Section<A> object for each mach-o section
+	// allocate MRFSection<A> object for each mach-o section
 	makeSections();
 	
 	// if it exists, do special early parsing of __compact_unwind section
@@ -1687,7 +1687,7 @@
 	#endif	
 	}
 	
-	Section<A>** sections = _file->_sectionsArray;
+	MRFSection<A>** sections = _file->_sectionsArray;
 	uint32_t	sectionsCount = _file->_sectionsArrayCount;
 
 	// figure out how many atoms will be allocated and allocate
@@ -2208,11 +2208,11 @@
 					_file->_objConstraint = ld::File::objcConstraintRetainRelease;
 				if ( sect->size() > 8 ) {
 					warning("section %s/%s has unexpectedly large size %llu in %s", 
-							sect->segname(), Section<A>::makeSectionName(sect), sect->size(), _file->path());
+							sect->segname(), MRFSection<A>::makeSectionName(sect), sect->size(), _file->path());
 				}
 			}
 			else {
-				warning("can't parse %s/%s section in %s", sect->segname(), Section<A>::makeSectionName(sect), _file->path());
+				warning("can't parse %s/%s section in %s", sect->segname(), MRFSection<A>::makeSectionName(sect), _file->path());
 			}
 			continue;
 		}
@@ -2308,24 +2308,24 @@
 	// sort by address (mach-o object files don't aways have sections sorted)
 	::qsort(machOSects, count, sizeof(MachOSectionAndSectionClass<P>), MachOSectionAndSectionClass<P>::sorter);
 		
-	// we will synthesize a dummy Section<A> object for tentative definitions
+	// we will synthesize a dummy MRFSection<A> object for tentative definitions
 	if ( _tentativeDefinitionCount > 0 ) {
 		totalSectionsSize += sizeof(TentativeDefinitionSection<A>);
 		machOSects[count++].type = sectionTypeTentativeDefinitions;
 	}
 	
-	// we will synthesize a dummy Section<A> object for Absolute symbols
+	// we will synthesize a dummy MRFSection<A> object for Absolute symbols
 	if ( _absoluteSymbolCount > 0 ) {
 		totalSectionsSize += sizeof(AbsoluteSymbolSection<A>);
 		machOSects[count++].type = sectionTypeAbsoluteSymbols;
 	}
 
 	// allocate one block for all Section objects as well as pointers to each
-	uint8_t* space = new uint8_t[totalSectionsSize+count*sizeof(Section<A>*)];
-	_file->_sectionsArray = (Section<A>**)space;
+	uint8_t* space = new uint8_t[totalSectionsSize+count*sizeof(MRFSection<A>*)];
+	_file->_sectionsArray = (MRFSection<A>**)space;
 	_file->_sectionsArrayCount = count;
-	Section<A>** objects = _file->_sectionsArray;
-	space += count*sizeof(Section<A>*);
+	MRFSection<A>** objects = _file->_sectionsArray;
+	space += count*sizeof(MRFSection<A>*);
 	for (uint32_t i=0; i < count; ++i) {
 		switch ( machOSects[i].type ) {
 			case sectionTypeIgnore:
@@ -2413,7 +2413,7 @@
 
 
 template <typename A>
-Section<A>* Parser<A>::sectionForAddress(typename A::P::uint_t addr)
+MRFSection<A>* Parser<A>::sectionForAddress(typename A::P::uint_t addr)
 {
 	for (uint32_t i=0; i < _file->_sectionsArrayCount; ++i ) {
 		const macho_section<typename A::P>* sect = _file->_sectionsArray[i]->machoSection();
@@ -2440,7 +2440,7 @@
 }
 
 template <typename A>
-Section<A>* Parser<A>::sectionForNum(unsigned int num)
+MRFSection<A>* Parser<A>::sectionForNum(unsigned int num)
 {
 	for (uint32_t i=0; i < _file->_sectionsArrayCount; ++i ) {
 		const macho_section<typename A::P>* sect = _file->_sectionsArray[i]->machoSection();
@@ -2456,7 +2456,7 @@
 template <typename A>
 Atom<A>* Parser<A>::findAtomByAddress(pint_t addr)
 {
-	Section<A>* section = this->sectionForAddress(addr);
+	MRFSection<A>* section = this->sectionForAddress(addr);
 	return section->findAtomByAddress(addr);
 }
 
@@ -2513,7 +2513,7 @@
 		target.addend = 0;
 		return;
 	}
-	Section<A>* section = this->sectionForAddress(addr);
+	MRFSection<A>* section = this->sectionForAddress(addr);
 	target.atom = section->findAtomByAddress(addr);
 	target.addend = addr - target.atom->_objAddress;
 	target.weakImport = false;
@@ -2561,7 +2561,7 @@
 		}
 		return;
 	}
-	Section<A>* section = this->sectionForNum(sectNum);
+	MRFSection<A>* section = this->sectionForNum(sectNum);
 	target.atom = section->findAtomByAddress(addr);
 	if ( target.atom == NULL ) {
 		typedef typename A::P::sint_t sint_t;
@@ -3723,7 +3723,7 @@
 }
 
 template <typename A>
-const char* Section<A>::makeSegmentName(const macho_section<typename A::P>* sect)
+const char* MRFSection<A>::makeSegmentName(const macho_section<typename A::P>* sect)
 {
 	// mach-o section record only has room for 16-byte seg/sect names
 	// so a 16-byte name has no trailing zero
@@ -3736,7 +3736,7 @@
 }
 
 template <typename A>
-const char* Section<A>::makeSectionName(const macho_section<typename A::P>* sect)
+const char* MRFSection<A>::makeSectionName(const macho_section<typename A::P>* sect)
 {
 	const char* name = sect->sectname();
 	if ( strlen(name) < 16 ) 
@@ -3770,13 +3770,13 @@
 }
 
 template <typename A>
-bool Section<A>::readable(const macho_section<typename A::P>* sect)
+bool MRFSection<A>::readable(const macho_section<typename A::P>* sect)
 {
 	return true;
 }
 
 template <typename A>
-bool Section<A>::writable(const macho_section<typename A::P>* sect)
+bool MRFSection<A>::writable(const macho_section<typename A::P>* sect)
 {
 	// mach-o .o files do not contain segment permissions
 	// we just know TEXT is special
@@ -3784,7 +3784,7 @@
 }
 
 template <typename A>
-bool Section<A>::exectuable(const macho_section<typename A::P>* sect)
+bool MRFSection<A>::exectuable(const macho_section<typename A::P>* sect)
 {
 	// mach-o .o files do not contain segment permissions
 	// we just know TEXT is special
@@ -3793,7 +3793,7 @@
 
 
 template <typename A>
-ld::Section::Type Section<A>::sectionType(const macho_section<typename A::P>* sect)
+ld::Section::Type MRFSection<A>::sectionType(const macho_section<typename A::P>* sect)
 {
 	switch ( sect->flags() & SECTION_TYPE ) {
 		case S_ZEROFILL:
@@ -3871,7 +3871,7 @@
 
 
 template <typename A>
-Atom<A>* Section<A>::findContentAtomByAddress(pint_t addr, class Atom<A>* start, class Atom<A>* end)
+Atom<A>* MRFSection<A>::findContentAtomByAddress(pint_t addr, class Atom<A>* start, class Atom<A>* end)
 {
 	// do a binary search of atom array
 	uint32_t atomCount = end - start;
@@ -3903,7 +3903,7 @@
 }
 
 template <typename A>
-ld::Atom::Alignment Section<A>::alignmentForAddress(pint_t addr) 
+ld::Atom::Alignment MRFSection<A>::alignmentForAddress(pint_t addr) 
 { 
 	const uint32_t sectionAlignment = this->_machOSection->align();
 	uint32_t modulus = (addr % (1 << sectionAlignment));
@@ -3913,7 +3913,7 @@
 }
 
 template <typename A>
-uint32_t Section<A>::sectionNum(class Parser<A>& parser) const	
+uint32_t MRFSection<A>::sectionNum(class Parser<A>& parser) const	
 { 
 	if ( _machOSection == NULL )
 		return 0;
@@ -4481,7 +4481,7 @@
 	else {
 		const pint_t* content = (pint_t*)(this->file().fileContent() + this->_machOSection->offset() + reloc->r_address());
 		pint_t personalityAddr = *content;
-		Section<x86_64>* personalitySection = parser.sectionForAddress(personalityAddr);
+		MRFSection<x86_64>* personalitySection = parser.sectionForAddress(personalityAddr);
 		assert((personalitySection->type() == ld::Section::typeCode) && "personality column in __compact_unwind section is not pointer to function");
 		// atoms may not be constructed yet, so scan symbol table for labels
 		const char* name = parser.scanSymbolTableForAddress(personalityAddr);
@@ -4501,7 +4501,7 @@
 		// support __LD, __compact_unwind personality entries which are pointer to personality non-lazy pointer
 		const pint_t* content = (pint_t*)(this->file().fileContent() + this->_machOSection->offset() + reloc->r_address());
 		pint_t nlPointerAddr = *content;
-		Section<x86>* nlSection = parser.sectionForAddress(nlPointerAddr);
+		MRFSection<x86>* nlSection = parser.sectionForAddress(nlPointerAddr);
 		if ( nlSection->type() == ld::Section::typeCode ) {
 			// personality function is defined in this .o file, so this is a direct reference to it
 			// atoms may not be constructed yet, so scan symbol table for labels
@@ -4528,7 +4528,7 @@
 	else {
 		const pint_t* content = (pint_t*)(this->file().fileContent() + this->_machOSection->offset() + reloc->r_address());
 		pint_t personalityAddr = *content;
-		Section<arm64>* personalitySection = parser.sectionForAddress(personalityAddr);
+		MRFSection<arm64>* personalitySection = parser.sectionForAddress(personalityAddr);
 		assert((personalitySection->type() == ld::Section::typeCode) && "personality column in __compact_unwind section is not pointer to function");
 		// atoms may not be constructed yet, so scan symbol table for labels
 		const char* name = parser.scanSymbolTableForAddress(personalityAddr);
@@ -4681,7 +4681,7 @@
 
 template <typename A>
 SymboledSection<A>::SymboledSection(Parser<A>& parser, File<A>& f, const macho_section<typename A::P>* s)
-	: Section<A>(f, s), _type(ld::Atom::typeUnclassified) 
+	: MRFSection<A>(f, s), _type(ld::Atom::typeUnclassified) 
 {
 	switch ( s->flags() & SECTION_TYPE ) {
 		case S_ZEROFILL:
@@ -4727,7 +4727,7 @@
 			if ( ! this->_file.canScatterAtoms() )
 				return true;
 			// call inherited
-			return Section<A>::dontDeadStrip();
+			return MRFSection<A>::dontDeadStrip();
 	}
 	return false;
 }
@@ -5572,7 +5572,7 @@
 
 
 template <>
-uint32_t Section<x86_64>::x86_64PcRelOffset(uint8_t r_type)
+uint32_t MRFSection<x86_64>::x86_64PcRelOffset(uint8_t r_type)
 {
 	switch ( r_type ) {
 		case X86_64_RELOC_SIGNED:
@@ -5589,7 +5589,7 @@
 
 
 template <>
-bool Section<x86_64>::addRelocFixup(class Parser<x86_64>& parser, const macho_relocation_info<P>* reloc)
+bool MRFSection<x86_64>::addRelocFixup(class Parser<x86_64>& parser, const macho_relocation_info<P>* reloc)
 {
 	const macho_section<P>* sect = this->machoSection();
 	uint64_t srcAddr = sect->addr() + reloc->r_address();
@@ -5796,7 +5796,7 @@
 
 
 template <>
-bool Section<x86>::addRelocFixup(class Parser<x86>& parser, const macho_relocation_info<P>* reloc)
+bool MRFSection<x86>::addRelocFixup(class Parser<x86>& parser, const macho_relocation_info<P>* reloc)
 {
 	const macho_section<P>* sect = this->machoSection();
 	uint32_t srcAddr;
@@ -6037,7 +6037,7 @@
 
 #if SUPPORT_ARCH_arm_any
 template <>
-bool Section<arm>::addRelocFixup(class Parser<arm>& parser, const macho_relocation_info<P>* reloc)
+bool MRFSection<arm>::addRelocFixup(class Parser<arm>& parser, const macho_relocation_info<P>* reloc)
 {
 	const macho_section<P>* sect = this->machoSection();
 	bool result = false;
@@ -6495,7 +6495,7 @@
 
 #if SUPPORT_ARCH_arm64
 template <>
-bool Section<arm64>::addRelocFixup(class Parser<arm64>& parser, const macho_relocation_info<P>* reloc)
+bool MRFSection<arm64>::addRelocFixup(class Parser<arm64>& parser, const macho_relocation_info<P>* reloc)
 {
 	bool result = false;
 	Parser<arm64>::SourceLocation	src;
@@ -6893,7 +6893,7 @@
 
 #if SUPPORT_ARCH_arm64
 template <>
-void Section<arm64>::addLOH(class Parser<arm64>& parser, int kind, int count, const uint64_t addrs[]) {
+void MRFSection<arm64>::addLOH(class Parser<arm64>& parser, int kind, int count, const uint64_t addrs[]) {
 	switch (kind) {
 		case LOH_ARM64_ADRP_ADRP:
 		case LOH_ARM64_ADRP_LDR:
@@ -6948,18 +6948,18 @@
 	extra.info.delta2 = (count > 1) ? ((addrs[1] - lowestAddress) >> 2) : 0;
 	extra.info.delta3 = (count > 2) ? ((addrs[2] - lowestAddress) >> 2) : 0;
 	extra.info.delta4 = (count > 3) ? ((addrs[3] - lowestAddress) >> 2) : 0;
-	typename Parser<arm64>::SourceLocation src(inAtom, lowestAddress- inAtom->objectAddress());
+	Parser<arm64>::SourceLocation src(inAtom, lowestAddress- inAtom->objectAddress());
 	parser.addFixup(src, ld::Fixup::k1of1, ld::Fixup::kindLinkerOptimizationHint, extra.addend);
 }
 #endif
 
 template <typename A>
-void Section<A>::addLOH(class Parser<A>& parser, int kind, int count, const uint64_t addrs[]) {
+void MRFSection<A>::addLOH(class Parser<A>& parser, int kind, int count, const uint64_t addrs[]) {
 
 }
 
 template <typename A>
-void Section<A>::makeFixups(class Parser<A>& parser, const struct Parser<A>::CFI_CU_InfoArrays&)
+void MRFSection<A>::makeFixups(class Parser<A>& parser, const struct Parser<A>::CFI_CU_InfoArrays&)
 {
 	const macho_section<P>* sect = this->machoSection();
 	const macho_relocation_info<P>* relocs = (macho_relocation_info<P>*)(file().fileContent() + sect->reloff());
@@ -6970,7 +6970,7 @@
 				++r; // skip next
 		}
 		catch (const char* msg) {
-			throwf("in section %s,%s reloc %u: %s", sect->segname(), Section<A>::makeSectionName(sect), r, msg);
+			throwf("in section %s,%s reloc %u: %s", sect->segname(), MRFSection<A>::makeSectionName(sect), r, msg);
 		}
 	}
 	
diff -ur ld64-236.3.orig/src/ld/passes/dtrace_dof.cpp ld64-236.3/src/ld/passes/dtrace_dof.cpp
--- ld64-236.3.orig/src/ld/passes/dtrace_dof.cpp	2014-04-05 00:42:29.000000000 +0200
+++ ld64-236.3/src/ld/passes/dtrace_dof.cpp	2015-01-12 00:27:58.000000000 +0100
@@ -30,8 +30,17 @@
 
 #include <vector>
 #include <map>
+#ifdef __GLIBCXX__
+#include <tr1/unordered_map>
+#include <tr1/unordered_set>
+#define UNORDERED_MAP tr1::unordered_map
+#define UNORDERED_SET tr1::unordered_set
+#else
 #include <unordered_map>
 #include <unordered_set>
+#define UNORDERED_MAP unordered_map
+#define UNORDERED_SET unordered_set
+#endif
 
 #include "ld.hpp"
 #include "MachOFileAbstraction.hpp"
@@ -111,8 +120,8 @@
 	uint32_t						offset;
 	const char*						probeName;
 };
-typedef std::unordered_map<const char*, std::vector<DTraceProbeInfo>, CStringHash, CStringEquals>	ProviderToProbes;
-typedef	std::unordered_set<const char*, CStringHash, CStringEquals>  CStringSet;
+typedef std::UNORDERED_MAP<const char*, std::vector<DTraceProbeInfo>, CStringHash, CStringEquals>	ProviderToProbes;
+typedef	std::UNORDERED_SET<const char*, CStringHash, CStringEquals>  CStringSet;
 
 
 
diff -ur ld64-236.3.orig/src/ld/passes/order.cpp ld64-236.3/src/ld/passes/order.cpp
--- ld64-236.3.orig/src/ld/passes/order.cpp	2014-04-05 00:42:29.000000000 +0200
+++ ld64-236.3/src/ld/passes/order.cpp	2015-01-11 22:45:57.000000000 +0100
@@ -32,7 +32,13 @@
 #include <vector>
 #include <map>
 #include <set>
+#ifdef __GLIBCXX__
+#include <tr1/unordered_map>
+#define UNORDERED_MAP tr1::unordered_map
+#else
 #include <unordered_map>
+#define UNORDERED_MAP unordered_map
+#endif
 
 #include "ld.hpp"
 #include "order.h"
@@ -84,7 +90,7 @@
 		const Layout&	_layout;
 	};
 				
-	typedef std::unordered_map<const char*, const ld::Atom*, CStringHash, CStringEquals> NameToAtom;
+	typedef std::UNORDERED_MAP<const char*, const ld::Atom*, CStringHash, CStringEquals> NameToAtom;
 	
 	typedef std::map<const ld::Atom*, const ld::Atom*> AtomToAtom;
 	
diff -ur ld64-236.3.orig/src/other/dyldinfo.cpp ld64-236.3/src/other/dyldinfo.cpp
--- ld64-236.3.orig/src/other/dyldinfo.cpp	2014-04-05 00:42:29.000000000 +0200
+++ ld64-236.3/src/other/dyldinfo.cpp	2015-01-12 00:27:33.000000000 +0100
@@ -33,7 +33,6 @@
 
 #include <vector>
 #include <set>
-#include <unordered_set>
 
 #include "configure.h"
 #include "MachOFileAbstraction.hpp"
diff -ur ld64-236.3.orig/src/other/machochecker.cpp ld64-236.3/src/other/machochecker.cpp
--- ld64-236.3.orig/src/other/machochecker.cpp	2014-04-05 00:42:29.000000000 +0200
+++ ld64-236.3/src/other/machochecker.cpp	2015-01-11 22:46:37.000000000 +0100
@@ -33,7 +33,13 @@
 
 #include <vector>
 #include <set>
+#ifdef __GLIBCXX__
+#include <tr1/unordered_set>
+#define UNORDERED_SET tr1::unordered_set
+#else
 #include <unordered_set>
+#define UNORDERED_SET unordered_set
+#endif
 
 #include "configure.h"
 
@@ -124,7 +130,7 @@
 		bool operator()(const char* left, const char* right) const { return (strcmp(left, right) == 0); }
 	};
 
-	typedef std::unordered_set<const char*, CStringHash, CStringEquals>  StringSet;
+	typedef std::UNORDERED_SET<const char*, CStringHash, CStringEquals>  StringSet;
 
 												MachOChecker(const uint8_t* fileContent, uint32_t fileLength, const char* path);
 	void										checkMachHeader();
diff -ur ld64-236.3.orig/src/other/unwinddump.cpp ld64-236.3/src/other/unwinddump.cpp
--- ld64-236.3.orig/src/other/unwinddump.cpp	2014-04-05 00:42:29.000000000 +0200
+++ ld64-236.3/src/other/unwinddump.cpp	2015-01-11 23:58:00.000000000 +0100
@@ -33,7 +33,6 @@
 
 #include <vector>
 #include <set>
-#include <unordered_set>
 
 #include "configure.h"
 #include "MachOFileAbstraction.hpp"
